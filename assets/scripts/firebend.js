"use strict";
exports.__esModule = true;
var fs = require("fs");
// get the input dir from the cmd
var inputDir = "./model/app";
var outputDir = "./firebends";
// this is the target folder from the import in the generated file
var relativeImportFolder = "../model";
// export interface <interfacename> {<any>}
var interfaceRegex = /export interface \w+ \s*[{]\s*[\s\S]*?\s*[}][\s]*\/\/\s*generate/gi;
// export interface (<interfacename>) | with capture on interfacename
var interfaceNameRegex = /export interface (\w+) \s*/;
// (<collectionname>): { [<any>: <any>]: (<interfacename>) }
var subColRegex = /(\w+)\s*[:]\s*[{][\s\S]*?[:][\s\S]*?[:]\s*(\w+)\s*[}]/gi;
// iterate all files from the folder
fs.readdir(inputDir, function (_, files) {
    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
        var file = files_1[_i];
        // read the file
        var fileContent = fs.readFileSync(inputDir + "/" + file);
        // find the interfaces
        var interfaceMatches = fileContent.toString().match(interfaceRegex);
        for (var _a = 0, _b = interfaceMatches; _a < _b.length; _a++) {
            var interfaceMatch = _b[_a];
            // the name of the parent interface
            var interfaceName = interfaceNameRegex.exec(interfaceMatch)[1];
            // make the name of the collection the name of the interface with the first letter in lowercase
            var collection = interfaceName.split("");
            collection[0] = collection[0].toLowerCase();
            var generatedCode = generateCollection(relativeImportFolder, file, interfaceName, collection.join("") + "s", collection.join(""));
            console.log(generatedCode);
            // check if there are subcollections
            var subCollections = interfaceMatch.match(subColRegex);
            if (subCollections) {
                for (var _c = 0, subCollections_1 = subCollections; _c < subCollections_1.length; _c++) {
                    var subCollection = subCollections_1[_c];
                    var capture = /(\w+)\s*[:]\s*[{][\s\S]*?[:][\s\S]*?[:]\s*(\w+)\s*[}]/gi.exec(subCollection);
                    if (capture) {
                        // write imports
                        generatedCode = generatedCode.replace("{{importsPlaceholder}}", "import { " + capture[2] + " } from \"" + relativeImportFolder + "/" + file.replace(".ts", "") + "\"\n\n                                {{importsPlaceholder}}");
                        // write exports
                        generatedCode = generatedCode
                            .replace("{{exportPlaceholder}}", capture[1] + ",\n{{exportPlaceholder}}");
                        var generatedSubcolCode = generateSubCollection(collection.join("") + "s", capture[1], capture[2]);
                        generatedCode = generatedCode.replace("{{subcollectionPlaceholder}}", generatedSubcolCode + "\n    {{subcollectionPlaceholder}}");
                    }
                }
            }
            generatedCode = generatedCode.replace("{{exportPlaceholder}}", "// end of exports");
            generatedCode = generatedCode.replace("{{importsPlaceholder}}", "");
            generatedCode = generatedCode.replace("{{subcollectionPlaceholder}}", "");
            fs.writeFile(outputDir + "/" + interfaceName + "s.ts", generatedCode, function (err) {
                console.log(err);
            });
        }
    }
});
var generateCollection = function (folderName, fileName, interfaceName, collectionPath, documentName) {
    return "\nimport firebase, { firestore, FirebaseError } from \"firebase\"\nimport { " + interfaceName + " } from \"" + folderName + "/" + fileName.replace(".ts", "") + "\"\n{{importsPlaceholder}}\n\nexport interface DocListenerCallback {\n    added: CallableFunction;\n    removed?: CallableFunction;\n    modified?: CallableFunction;\n}\n\nconst db = firebase.firestore()\nconst collectionPath = \"" + collectionPath + "\"\n\n/** Adds new record and generates new id */\nconst add = (" + documentName + ": " + interfaceName + ") => {\n    return new Promise<firestore.DocumentReference>((resolve, reject) => {\n        db.collection(collectionPath).add(" + documentName + ")\n            .then((ref: firestore.DocumentReference) => {\n                resolve(ref)\n            })\n            .catch((error: FirebaseError) => reject(error))\n    })\n}\n\n/**\n * Updates existing record by merging passed values with existing ones.\n * Fails if record does not exist\n */\nconst update = (id: string, " + documentName + ": " + interfaceName + ") => {\n    return new Promise((resolve, reject) => {\n        db.collection(collectionPath).doc(id)\n            .update(" + documentName + ")\n            .then(() => resolve())\n            .catch((error: FirebaseError) => reject(error))\n    })\n}\n\n/** Overwrites existing record, creates one if it does not exist */\nconst set = (id: string, " + documentName + ": " + interfaceName + ") => {\n    return new Promise((resolve, reject) => {\n        db.collection(collectionPath).doc(id)\n            .set(" + documentName + ")\n            .then(() => resolve())\n            .catch((error: FirebaseError) => reject(error))\n    })\n}\n\n/** Permanently removes a record from the database using id */\nconst hardDelete = (id: string) => {\n    return new Promise((resolve, reject) => {\n        db.collection(collectionPath).doc(id).delete()\n            .then(() => resolve)\n            .catch((error: FirebaseError) => reject(error))\n    });\n}\n\n/** Targets a specific document and listens to updates real-time using id */\nconst listenToOne = (id: string, callback: (" + documentName + ": " + interfaceName + ") => void) => {\n    db.collection(collectionPath)\n        .doc(id).onSnapshot((doc: firestore.DocumentSnapshot) => {\n            callback(doc.data() as " + interfaceName + ")\n        })\n}\n\n/** Gets a specific document once using id */\nconst getOne = (childId: string) => {\n    return new Promise<" + interfaceName + ">((resolve, reject) => {\n        db.collection(collectionPath)\n            .doc(childId)\n            .get().then((doc: firestore.DocumentSnapshot) => {\n                resolve(doc.data() as " + interfaceName + ")\n            }).catch((error: FirebaseError) => reject(error))\n    })\n}\n\n/** Gets all document in a collection once */\nconst getAll = () => {\n    return new Promise<" + interfaceName + "[]>((resolve, reject) => {\n        const items: " + interfaceName + "[] = []\n        db.collection(collectionPath).get().then((querySnapshot: firestore.QuerySnapshot) => {\n            querySnapshot.forEach((doc) => {\n                doc.data()\n                items.push(doc.data() as " + interfaceName + ")\n            })\n            resolve(items)\n        }).catch((error) => {\n            reject(error)\n        })\n    });\n}\n\n/** Listens in real-time to all documents */\nconst listenToAll = (callback: DocListenerCallback) => {\n    db.collection(collectionPath)\n        .onSnapshot((snapshot) => {\n            snapshot.docChanges().forEach((change: firestore.DocumentChange) => {\n                if (change.type === \"added\") {\n                    callback.added(change.doc)\n                }\n                if (change.type === \"modified\") {\n                    callback.modified!!(change.doc)\n                }\n                if (change.type === \"removed\") {\n                    callback.removed!!(change.doc)\n                }\n            });\n        });\n}\n\n/** Gets a specific document once with query params */\nconst queryOnce = (params: " + interfaceName + ") => {\n    return new Promise<" + interfaceName + "[]>((resolve, reject) => {\n        let queryStore: any = db.collection(collectionPath)\n\n        for (const key of Object.keys(params)) {\n            queryStore = queryStore.where(key, \"==\", params[key])\n        }\n\n        queryStore.get().then((snapshot: firestore.QuerySnapshot) => {\n            const results: " + interfaceName + "[] = []\n            snapshot.docs.forEach((doc: firestore.DocumentSnapshot) => {\n                results.push(doc.data() as " + interfaceName + ")\n            })\n            resolve(results)\n        }).catch((error: FirebaseError) => reject(error))\n    })\n}\n\n/**\n * Pushes a new document. Will fail if a similar record\n * already exists based on the identifier provided\n */\nconst addUnique = (params: " + interfaceName + ", " + documentName + ": " + interfaceName + ") => {\n    return new Promise<firestore.DocumentReference>((resolve, reject) => {\n        queryOnce(params).then((results: " + interfaceName + "[]) => {\n            if (results.length === 0) {\n                add(" + documentName + ")\n                    .then((ref: firestore.DocumentReference) => resolve(ref))\n                    .catch((error: FirebaseError) => reject(error))\n            } else {\n                // document exists, throw error\n                reject(\"Unable to add unique. The document already exists.\")\n            }\n        })\n    })\n}\n\nexport interface BatchOperation {\n    batchUpdate: (id: string, " + documentName + ": " + interfaceName + ") => BatchOperation\n    batchSet: (id: string, " + documentName + ": " + interfaceName + ") => BatchOperation\n    batchDelete: (id: string) => BatchOperation\n    commit: () => Promise<void>\n    get: () => firestore.WriteBatch\n}\n\n/** Batch operations that can be chained */\nconst beginBatch = function (batch?: firestore.WriteBatch) {\n    let dbBatch: firestore.WriteBatch\n\n    if (batch) {\n        dbBatch = batch\n    } else {\n        dbBatch = db.batch()\n    }\n\n    let operations: BatchOperation\n    const batchUpdate = (id: string, " + documentName + ": " + interfaceName + "): BatchOperation => {\n        const updateRef = db.collection(collectionPath).doc(id)\n        dbBatch.update(updateRef, " + documentName + ")\n        return operations\n    }\n\n    const batchSet = (id: string, " + documentName + ": " + interfaceName + "): BatchOperation => {\n        const setRef = db.collection(collectionPath).doc(id)\n        dbBatch.set(setRef, " + documentName + ")\n        return operations\n    }\n\n    const batchDelete = (id: string): BatchOperation => {\n        return operations\n    }\n\n    const commit = (): Promise<void> => {\n        return new Promise<void>((resolve, reject) => {\n            dbBatch.commit().then(() => {\n                resolve()\n            }).catch((error) => {\n                reject(error)\n            })\n        });\n    }\n\n    // Returns the batch so it can be used by another beginBatch() function\n    const get = (): firestore.WriteBatch => {\n        return dbBatch\n    }\n\n    operations = {\n        batchUpdate,\n        batchSet,\n        batchDelete,\n        commit,\n        get\n    }\n    return operations\n}\n\n{{subcollectionPlaceholder}}\n\nexport default {\n    add,\n    update,\n    set,\n    hardDelete,\n    listenToOne,\n    getOne,\n    addUnique,\n    queryOnce,\n    beginBatch,\n    listenToAll\n    {{exportPlaceholder}}\n}\n\n";
};
var generateSubCollection = function (collectionPath, subcollectionPath, interfaceName) {
    var docName = subcollectionPath.split("");
    if (docName[docName.length - 1] === "s") {
        docName.pop();
    }
    docName = docName.join("");
    return "\nconst " + subcollectionPath + " = (id: string) => {\n    const collectionPath = \"" + collectionPath + "\"\n    const subcollectionPath = \"" + subcollectionPath + "\"\n    /** Adds new record and generates new id */\n    const add = (" + docName + ": " + interfaceName + ") => {\n        return new Promise<firestore.DocumentReference>((resolve, reject) => {\n            db.collection(collectionPath)\n                .doc(id)\n                .collection(subcollectionPath).add(" + docName + ")\n                .then((ref: firestore.DocumentReference) => {\n                    resolve(ref)\n                })\n                .catch((error: FirebaseError) => reject(error))\n        })\n    }\n\n    /**\n     * Updates existing record by merging passed values with existing ones.\n     * Fails if record does not exist\n     */\n    const update = (childId: string, " + docName + ": " + interfaceName + ") => {\n        return new Promise((resolve, reject) => {\n            db.collection(collectionPath)\n                .doc(id)\n                .collection(subcollectionPath)\n                .doc(childId)\n                .update(" + docName + ")\n                .then(() => resolve())\n                .catch((error: FirebaseError) => reject(error))\n        })\n    }\n\n    /** Overwrites existing record, creates one if it does not exist */\n    const set = (childId: string, " + docName + ": " + interfaceName + ") => {\n        return new Promise((resolve, reject) => {\n            db.collection(collectionPath)\n                .doc(id)\n                .collection(subcollectionPath)\n                .doc(childId)\n                .set(" + docName + ")\n                .then(() => resolve())\n                .catch((error: FirebaseError) => reject(error))\n        })\n    }\n\n    /** Permanently removes a record from the database using id */\n    const hardDelete = (childId: string) => {\n        return new Promise((resolve, reject) => {\n            db.collection(collectionPath)\n                .doc(id)\n                .collection(subcollectionPath)\n                .doc(childId)\n                .delete()\n                .then(() => resolve)\n                .catch((error: FirebaseError) => reject(error))\n        });\n    }\n\n    /** Targets a specific document and listens to updates real-time using id */\n    const listenToOne = (childId: string, callback: (" + docName + ": " + interfaceName + ") => void) => {\n        db.collection(collectionPath)\n            .doc(id)\n            .collection(subcollectionPath)\n            .doc(childId)\n            .onSnapshot((doc: firestore.DocumentSnapshot) => {\n                callback(doc.data() as " + interfaceName + ")\n            })\n    }\n\n    /** Gets a specific document once using id */\n    const getOne = (childId: string) => {\n        return new Promise<" + interfaceName + ">((resolve, reject) => {\n            db.collection(collectionPath)\n                .doc(id)\n                .collection(subcollectionPath)\n                .doc(childId)\n                .get().then((doc: firestore.DocumentSnapshot) => {\n                    resolve(doc.data() as " + interfaceName + ")\n                }).catch((error: FirebaseError) => reject(error))\n        })\n    }\n\n        /** Gets all document in a collection once */\n    const getAll = () => {\n        return new Promise<" + interfaceName + "[]>((resolve, reject) => {\n            const items: " + interfaceName + "[] = []\n            db.collection(collectionPath)\n            .doc(id)\n            .collection(subcollectionPath)\n            .get().then((querySnapshot: firestore.QuerySnapshot) => {\n                querySnapshot.forEach((doc) => {\n                    doc.data()\n                    items.push(doc.data() as " + interfaceName + ")\n                })\n                resolve(items)\n            }).catch((error) => {\n                reject(error)\n            })\n        });\n    }\n\n    /** Listens in real-time to all documents */\n    const listenToAll = (callback: DocListenerCallback) => {\n        db.collection(collectionPath)\n            .doc(id)\n            .collection(subcollectionPath)\n            .onSnapshot((snapshot) => {\n                snapshot.docChanges().forEach((change: firestore.DocumentChange) => {\n                    if (change.type === \"added\") {\n                        callback.added(change.doc)\n                    }\n                    if (change.type === \"modified\") {\n                        callback.modified!!(change.doc)\n                    }\n                    if (change.type === \"removed\") {\n                        callback.removed!!(change.doc)\n                    }\n                });\n            });\n    }\n\n    /** Gets a specific document once with query params */\n    const queryOnce = (params: " + interfaceName + ") => {\n        return new Promise<" + interfaceName + "[]>((resolve, reject) => {\n            let queryStore: any = db.collection(collectionPath)\n                .doc(id)\n                .collection(subcollectionPath)\n                .doc(id).collection(subcollectionPath)\n\n            for (const key of Object.keys(params)) {\n                queryStore = queryStore.where(key, \"==\", params[key])\n            }\n\n            queryStore.get().then((snapshot: firestore.QuerySnapshot) => {\n                const results: " + interfaceName + "[] = []\n                snapshot.docs.forEach((doc: firestore.DocumentSnapshot) => {\n                    results.push(doc.data() as " + interfaceName + ")\n                })\n                resolve(results)\n            }).catch((error: FirebaseError) => reject(error))\n        })\n    }\n\n    /**\n     * Pushes a new document. Will fail if a similar record\n     * already exists based on the identifier provided\n     */\n    const addUnique = (params: " + interfaceName + ", " + docName + ": " + interfaceName + ") => {\n        return new Promise<firestore.DocumentReference>((resolve, reject) => {\n            queryOnce(params).then((results: " + interfaceName + "[]) => {\n                if (results.length === 0) {\n                    add(" + docName + ")\n                        .then((ref: firestore.DocumentReference) => resolve(ref))\n                        .catch((error: FirebaseError) => reject(error))\n                } else {\n                    // document exists, throw error\n                    reject(\"Unable to add unique. The document already exists.\")\n                }\n            })\n        })\n    }\n    return {\n        add,\n        update,\n        set,\n        hardDelete,\n        listenToOne,\n        getOne,\n        addUnique,\n        queryOnce,\n        beginBatch,\n        listenToAll\n    }\n}\n";
};
exports["default"] = {};
